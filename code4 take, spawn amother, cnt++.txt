#include <iostream>
#include <ncurses.h>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <ctime>

using namespace std;

#define MAIN_COLOR      1
#define REV_COLOR       2
#define BOTTOM_COLOR    3

void position(WINDOW* w, int collected){
    mvwprintw(w,2,3,"collected:%2d",collected);
}

void timerpos(WINDOW* w, int seconds){
    mvwprintw(w,1,3,"Time left:%d",seconds);
}

vector<pair<int,int>> generate_asterisk(int numberOfLines, int numberOfColumns) {
    vector<pair<int,int>> coordinates;
    srand(time(0)); 
    while(coordinates.size() < 10) {
        int x = rand() % (COLS - 2) + 1;
        int y = rand() % (LINES - 4) + 1;
        pair<int,int> coord = make_pair(x,y);
        if(find(coordinates.begin(), coordinates.end(), coord) == coordinates.end()) {
            coordinates.push_back(coord);
        }
    }
    return coordinates;
}

void spawnAsterisk(WINDOW* win, int x_max, int y_max, std::vector<std::pair<int, int>>& asterisk_coords)
{
    // Generate new coordinates for the asterisk
    int new_x = rand() % COLS;
    int new_y = rand() % LINES;

    // Check if the new coordinates conflict with existing asterisks
    bool conflict = false;
    for (const auto& coord : asterisk_coords)
    {
        if (coord.first == new_x && coord.second == new_y)
        {
            conflict = true;
            break;
        }
    }

    // If there's a conflict, generate new coordinates until there's no conflict
    while (conflict)
    {
        new_x = rand() % x_max;
        new_y = rand() % y_max;

        conflict = false;
        for (const auto& coord : asterisk_coords)
        {
            if (coord.first == new_x && coord.second == new_y)
            {
                conflict = true;
                break;
            }
        }
    }

    asterisk_coords.push_back(std::make_pair(new_x, new_y));

    mvwprintw(win, new_y, new_x, "*");
    wrefresh(win);
}


int main()
{
	WINDOW* mainwin,*stat,*timer;
	string C = "*", C_wh;
	int x =20 , y =10 ;
	int collected=0;
	int left=10;
    int seconds=30;
    int key;

    for(int i=0; i < C.size(); i++) C_wh += " ";

    mainwin = initscr();    
    stat=subwin(mainwin,3,20,LINES-4,1);
    timer=subwin(mainwin,3,15,LINES-3,COLS-17);
    curs_set(0);            
    noecho();               
    keypad(mainwin, true);


    start_color();
    init_pair(MAIN_COLOR, COLOR_YELLOW, COLOR_YELLOW);
    init_pair(REV_COLOR,COLOR_YELLOW,COLOR_BLACK);
    init_pair(BOTTOM_COLOR,COLOR_RED,COLOR_BLACK);

    wattron(mainwin,COLOR_PAIR(MAIN_COLOR));
    mvwprintw(mainwin,y,x,"%s",C.c_str());
    box(mainwin,0,0);   
    wattroff(mainwin,COLOR_PAIR(MAIN_COLOR));




    wattron(timer,COLOR_PAIR(BOTTOM_COLOR));
    wattron(stat,COLOR_PAIR(BOTTOM_COLOR));

    

    wrefresh(stat);
    wrefresh(timer);
    
    //spawn red asterisks
    wattron(mainwin,COLOR_PAIR(BOTTOM_COLOR));
    vector<pair<int,int>> asterisk_coords = generate_asterisk(LINES,COLS);
    for(const auto& coord : asterisk_coords) {
                mvwprintw(mainwin, coord.second, coord.first, "%s", C.c_str());
        }
    wattroff(mainwin,COLOR_PAIR(BOTTOM_COLOR));
    
    
    wattron(mainwin,COLOR_PAIR(MAIN_COLOR));
    position(stat,collected);
    timerpos(timer,seconds);
    wrefresh(stat);
    wrefresh(timer);
    wrefresh(mainwin);

    while ( 1 ) // MAIN LOOP
    {
        key = wgetch(mainwin);  // wait for key pressed: BLOCKING
        wattron(mainwin,COLOR_PAIR(REV_COLOR));
        mvwprintw(mainwin,y,x,"%s",C_wh.c_str());

		//CHECK MOVEMENT
        if (key == 'a' || key==KEY_LEFT) {x-=1;}
        else if (key == 'd' || key==KEY_RIGHT) {x+=1;}       
        else if (key == 'w' || key==KEY_UP) {y-=1;}       
        else if (key=='s' || key==KEY_DOWN) {y+=1;}
        else if (key == 'q'){break;}

		
		// CHECK IF PLAYER HIT BORDERS
        if(y==0){y=y+4;}
        else if(y==LINES-2){y-=4;}
        if(x==0){x+=4;}
        else if(x==COLS-1){x-=4;}
 		
 		
 		// CHECK IF PLAYER COLLECTED ASTERISKS
		for (auto it = asterisk_coords.begin(); it != asterisk_coords.end();)
		{
        	if (x == it->first && y == it->second) 
			{
            	collected++;
            	left--;
            	mvwprintw(mainwin, it->second, it->first, " "); 
            	it = asterisk_coords.erase(it); 
                wattroff(mainwin,COLOR_PAIR(MAIN_COLOR));
                wattron(mainwin,COLOR_PAIR(BOTTOM_COLOR));
                spawnAsterisk(mainwin, COLS-1, LINES-3, asterisk_coords);
                wattroff(mainwin,COLOR_PAIR(BOTTOM_COLOR));
                wattron(mainwin,COLOR_PAIR(MAIN_COLOR));
            	position(stat, collected);
            	wrefresh(stat);
        	} 
			else {++it;}
    	}
    	
        wattron(mainwin,COLOR_PAIR(MAIN_COLOR));
        mvwprintw(mainwin,y,x,"%s",C.c_str());
        position(stat,collected);
        timerpos(timer,seconds);
        wrefresh(mainwin);      
        wrefresh(stat);
        wrefresh(timer);
    }

        delwin(mainwin);        
        endwin();               

        return EXIT_SUCCESS;
}

